
// <auto-generated>
// This code was generated by a T4 template.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

namespace Detach.Buffers;

[InlineArray(Size)]
[DebuggerDisplay("Items = {Items}")]
[SuppressMessage("StyleCop.CSharp.NamingRules", "SA1306:Field names should begin with lower-case letter", Justification = "InlineArray")]
[SuppressMessage("Roslynator", "RCS1213:Remove unused member declaration", Justification = "InlineArray")]
public struct Buffer4<T> : IEquatable<Buffer4<T>>
	where T : struct
{
	private const int Size = 4;

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private T _0;

	public Buffer4(params ReadOnlySpan<T> values)
	{
		for (int i = 0; i < Math.Min(values.Length, Size); i++)
			this[i] = values[i];
	}

	[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
	internal T[] Items => this[..Size].ToArray();

	public static bool operator ==(Buffer4<T> left, Buffer4<T> right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(Buffer4<T> left, Buffer4<T> right)
	{
		return !left.Equals(right);
	}

	public bool Equals(Buffer4<T> other)
	{
		for (int i = 0; i < Size; i++)
		{
			if (!this[i].Equals(other[i]))
				return false;
		}

		return true;
	}

	public override bool Equals(object? obj)
	{
		return obj is Buffer4<T> other && Equals(other);
	}

	public override int GetHashCode()
	{
		HashCode hash = default;
		for (int i = 0; i < Size; i++)
			hash.Add(this[i]);
		return hash.ToHashCode();
	}
}

[InlineArray(Size)]
[DebuggerDisplay("Items = {Items}")]
[SuppressMessage("StyleCop.CSharp.NamingRules", "SA1306:Field names should begin with lower-case letter", Justification = "InlineArray")]
[SuppressMessage("Roslynator", "RCS1213:Remove unused member declaration", Justification = "InlineArray")]
public struct Buffer6<T> : IEquatable<Buffer6<T>>
	where T : struct
{
	private const int Size = 6;

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private T _0;

	public Buffer6(params ReadOnlySpan<T> values)
	{
		for (int i = 0; i < Math.Min(values.Length, Size); i++)
			this[i] = values[i];
	}

	[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
	internal T[] Items => this[..Size].ToArray();

	public static bool operator ==(Buffer6<T> left, Buffer6<T> right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(Buffer6<T> left, Buffer6<T> right)
	{
		return !left.Equals(right);
	}

	public bool Equals(Buffer6<T> other)
	{
		for (int i = 0; i < Size; i++)
		{
			if (!this[i].Equals(other[i]))
				return false;
		}

		return true;
	}

	public override bool Equals(object? obj)
	{
		return obj is Buffer6<T> other && Equals(other);
	}

	public override int GetHashCode()
	{
		HashCode hash = default;
		for (int i = 0; i < Size; i++)
			hash.Add(this[i]);
		return hash.ToHashCode();
	}
}

[InlineArray(Size)]
[DebuggerDisplay("Items = {Items}")]
[SuppressMessage("StyleCop.CSharp.NamingRules", "SA1306:Field names should begin with lower-case letter", Justification = "InlineArray")]
[SuppressMessage("Roslynator", "RCS1213:Remove unused member declaration", Justification = "InlineArray")]
public struct Buffer8<T> : IEquatable<Buffer8<T>>
	where T : struct
{
	private const int Size = 8;

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private T _0;

	public Buffer8(params ReadOnlySpan<T> values)
	{
		for (int i = 0; i < Math.Min(values.Length, Size); i++)
			this[i] = values[i];
	}

	[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
	internal T[] Items => this[..Size].ToArray();

	public static bool operator ==(Buffer8<T> left, Buffer8<T> right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(Buffer8<T> left, Buffer8<T> right)
	{
		return !left.Equals(right);
	}

	public bool Equals(Buffer8<T> other)
	{
		for (int i = 0; i < Size; i++)
		{
			if (!this[i].Equals(other[i]))
				return false;
		}

		return true;
	}

	public override bool Equals(object? obj)
	{
		return obj is Buffer8<T> other && Equals(other);
	}

	public override int GetHashCode()
	{
		HashCode hash = default;
		for (int i = 0; i < Size; i++)
			hash.Add(this[i]);
		return hash.ToHashCode();
	}
}

[InlineArray(Size)]
[DebuggerDisplay("Items = {Items}")]
[SuppressMessage("StyleCop.CSharp.NamingRules", "SA1306:Field names should begin with lower-case letter", Justification = "InlineArray")]
[SuppressMessage("Roslynator", "RCS1213:Remove unused member declaration", Justification = "InlineArray")]
public struct Buffer12<T> : IEquatable<Buffer12<T>>
	where T : struct
{
	private const int Size = 12;

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private T _0;

	public Buffer12(params ReadOnlySpan<T> values)
	{
		for (int i = 0; i < Math.Min(values.Length, Size); i++)
			this[i] = values[i];
	}

	[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
	internal T[] Items => this[..Size].ToArray();

	public static bool operator ==(Buffer12<T> left, Buffer12<T> right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(Buffer12<T> left, Buffer12<T> right)
	{
		return !left.Equals(right);
	}

	public bool Equals(Buffer12<T> other)
	{
		for (int i = 0; i < Size; i++)
		{
			if (!this[i].Equals(other[i]))
				return false;
		}

		return true;
	}

	public override bool Equals(object? obj)
	{
		return obj is Buffer12<T> other && Equals(other);
	}

	public override int GetHashCode()
	{
		HashCode hash = default;
		for (int i = 0; i < Size; i++)
			hash.Add(this[i]);
		return hash.ToHashCode();
	}
}

[InlineArray(Size)]
[DebuggerDisplay("Items = {Items}")]
[SuppressMessage("StyleCop.CSharp.NamingRules", "SA1306:Field names should begin with lower-case letter", Justification = "InlineArray")]
[SuppressMessage("Roslynator", "RCS1213:Remove unused member declaration", Justification = "InlineArray")]
public struct Buffer16<T> : IEquatable<Buffer16<T>>
	where T : struct
{
	private const int Size = 16;

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private T _0;

	public Buffer16(params ReadOnlySpan<T> values)
	{
		for (int i = 0; i < Math.Min(values.Length, Size); i++)
			this[i] = values[i];
	}

	[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
	internal T[] Items => this[..Size].ToArray();

	public static bool operator ==(Buffer16<T> left, Buffer16<T> right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(Buffer16<T> left, Buffer16<T> right)
	{
		return !left.Equals(right);
	}

	public bool Equals(Buffer16<T> other)
	{
		for (int i = 0; i < Size; i++)
		{
			if (!this[i].Equals(other[i]))
				return false;
		}

		return true;
	}

	public override bool Equals(object? obj)
	{
		return obj is Buffer16<T> other && Equals(other);
	}

	public override int GetHashCode()
	{
		HashCode hash = default;
		for (int i = 0; i < Size; i++)
			hash.Add(this[i]);
		return hash.ToHashCode();
	}
}

[InlineArray(Size)]
[DebuggerDisplay("Items = {Items}")]
[SuppressMessage("StyleCop.CSharp.NamingRules", "SA1306:Field names should begin with lower-case letter", Justification = "InlineArray")]
[SuppressMessage("Roslynator", "RCS1213:Remove unused member declaration", Justification = "InlineArray")]
public struct Buffer24<T> : IEquatable<Buffer24<T>>
	where T : struct
{
	private const int Size = 24;

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private T _0;

	public Buffer24(params ReadOnlySpan<T> values)
	{
		for (int i = 0; i < Math.Min(values.Length, Size); i++)
			this[i] = values[i];
	}

	[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
	internal T[] Items => this[..Size].ToArray();

	public static bool operator ==(Buffer24<T> left, Buffer24<T> right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(Buffer24<T> left, Buffer24<T> right)
	{
		return !left.Equals(right);
	}

	public bool Equals(Buffer24<T> other)
	{
		for (int i = 0; i < Size; i++)
		{
			if (!this[i].Equals(other[i]))
				return false;
		}

		return true;
	}

	public override bool Equals(object? obj)
	{
		return obj is Buffer24<T> other && Equals(other);
	}

	public override int GetHashCode()
	{
		HashCode hash = default;
		for (int i = 0; i < Size; i++)
			hash.Add(this[i]);
		return hash.ToHashCode();
	}
}

[InlineArray(Size)]
[DebuggerDisplay("Items = {Items}")]
[SuppressMessage("StyleCop.CSharp.NamingRules", "SA1306:Field names should begin with lower-case letter", Justification = "InlineArray")]
[SuppressMessage("Roslynator", "RCS1213:Remove unused member declaration", Justification = "InlineArray")]
public struct Buffer32<T> : IEquatable<Buffer32<T>>
	where T : struct
{
	private const int Size = 32;

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private T _0;

	public Buffer32(params ReadOnlySpan<T> values)
	{
		for (int i = 0; i < Math.Min(values.Length, Size); i++)
			this[i] = values[i];
	}

	[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
	internal T[] Items => this[..Size].ToArray();

	public static bool operator ==(Buffer32<T> left, Buffer32<T> right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(Buffer32<T> left, Buffer32<T> right)
	{
		return !left.Equals(right);
	}

	public bool Equals(Buffer32<T> other)
	{
		for (int i = 0; i < Size; i++)
		{
			if (!this[i].Equals(other[i]))
				return false;
		}

		return true;
	}

	public override bool Equals(object? obj)
	{
		return obj is Buffer32<T> other && Equals(other);
	}

	public override int GetHashCode()
	{
		HashCode hash = default;
		for (int i = 0; i < Size; i++)
			hash.Add(this[i]);
		return hash.ToHashCode();
	}
}

