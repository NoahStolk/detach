// <auto-generated>
// This code was auto-generated.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable
using Detach.Collisions;
using Detach.Collisions.Primitives2D;
using Detach.Collisions.Primitives3D;
using System.Numerics;

namespace CollisionFormats.Execution;

public static class ExecutableCollisionAlgorithms
{
	private static readonly List<IExecutableCollisionAlgorithm> _all =
	[
		new Detach_Collisions_Geometry2D_CircleCircle_Circle_Circle_(),
		new Detach_Collisions_Geometry2D_CircleRectangle_Circle_Rectangle_(),
		new Detach_Collisions_Geometry2D_CircleOrientedRectangle_Circle_OrientedRectangle_(),
		new Detach_Collisions_Geometry2D_CircleTriangle_Circle_Triangle2D_(),
		new Detach_Collisions_Geometry2D_CircleCastPoint_CircleCast_Vector2_(),
		new Detach_Collisions_Geometry2D_CircleCastLine_CircleCast_LineSegment2D_(),
		new Detach_Collisions_Geometry2D_LineLine_LineSegment2D_LineSegment2D_(),
		new Detach_Collisions_Geometry2D_LineCircle_LineSegment2D_Circle_(),
		new Detach_Collisions_Geometry2D_LineRectangle_LineSegment2D_Rectangle_(),
		new Detach_Collisions_Geometry2D_LineOrientedRectangle_LineSegment2D_OrientedRectangle_(),
		new Detach_Collisions_Geometry2D_LineTriangle_LineSegment2D_Triangle2D_(),
		new Detach_Collisions_Geometry2D_OrientedRectangleOrientedRectangleSat_OrientedRectangle_OrientedRectangle_(),
		new Detach_Collisions_Geometry2D_OrientedRectangleTriangle_OrientedRectangle_Triangle2D_(),
		new Detach_Collisions_Geometry2D_PointOnLine_Vector2_LineSegment2D_Single_(),
		new Detach_Collisions_Geometry2D_PointInCircle_Vector2_Circle_(),
		new Detach_Collisions_Geometry2D_PointInRectangle_Vector2_Rectangle_(),
		new Detach_Collisions_Geometry2D_PointInOrientedRectangle_Vector2_OrientedRectangle_(),
		new Detach_Collisions_Geometry2D_PointInTriangle_Vector2_Triangle2D_(),
		new Detach_Collisions_Geometry2D_ClosestPointOnLine_Vector2_LineSegment2D_(),
		new Detach_Collisions_Geometry2D_RectangleRectangle_Rectangle_Rectangle_(),
		new Detach_Collisions_Geometry2D_RectangleRectangleSat_Rectangle_Rectangle_(),
		new Detach_Collisions_Geometry2D_RectangleOrientedRectangleSat_Rectangle_OrientedRectangle_(),
		new Detach_Collisions_Geometry2D_RectangleTriangle_Rectangle_Triangle2D_(),
		new Detach_Collisions_Geometry3D_AabbAabb_Aabb_Aabb_(),
		new Detach_Collisions_Geometry3D_AabbObbSat_Aabb_Obb_(),
		new Detach_Collisions_Geometry3D_AabbPlane_Aabb_Plane_(),
		new Detach_Collisions_Geometry3D_AabbCylinder_Aabb_Cylinder_(),
		new Detach_Collisions_Geometry3D_CylinderCylinder_Cylinder_Cylinder_(),
		new Detach_Collisions_Geometry3D_Linetest_Sphere_LineSegment3D_(),
		new Detach_Collisions_Geometry3D_Linetest_Aabb_LineSegment3D_(),
		new Detach_Collisions_Geometry3D_Linetest_Obb_LineSegment3D_(),
		new Detach_Collisions_Geometry3D_Linetest_Plane_LineSegment3D_(),
		new Detach_Collisions_Geometry3D_Linetest_Triangle3D_LineSegment3D_(),
		new Detach_Collisions_Geometry3D_ObbObbSat_Obb_Obb_(),
		new Detach_Collisions_Geometry3D_ObbPlane_Obb_Plane_(),
		new Detach_Collisions_Geometry3D_PlanePlane_Plane_Plane_(),
		new Detach_Collisions_Geometry3D_PointInSphere_Vector3_Sphere_(),
		new Detach_Collisions_Geometry3D_PointInAabb_Vector3_Aabb_(),
		new Detach_Collisions_Geometry3D_PointInObb_Vector3_Obb_(),
		new Detach_Collisions_Geometry3D_PointOnPlane_Vector3_Plane_(),
		new Detach_Collisions_Geometry3D_PointOnLine_Vector3_LineSegment3D_(),
		new Detach_Collisions_Geometry3D_PointOnRay_Vector3_Ray_(),
		new Detach_Collisions_Geometry3D_PointInTriangle_Vector3_Triangle3D_(),
		new Detach_Collisions_Geometry3D_PointInViewFrustum_Vector3_ViewFrustum_(),
		new Detach_Collisions_Geometry3D_PointInCylinder_Vector3_Cylinder_(),
		new Detach_Collisions_Geometry3D_PointInPyramid_Vector3_Pyramid_(),
		new Detach_Collisions_Geometry3D_PointInOrientedPyramid_Vector3_OrientedPyramid_(),
		new Detach_Collisions_Geometry3D_ClosestPointInSphere_Vector3_Sphere_(),
		new Detach_Collisions_Geometry3D_ClosestPointInAabb_Vector3_Aabb_(),
		new Detach_Collisions_Geometry3D_ClosestPointInObb_Vector3_Obb_(),
		new Detach_Collisions_Geometry3D_ClosestPointOnPlane_Vector3_Plane_(),
		new Detach_Collisions_Geometry3D_ClosestPointOnLine_Vector3_LineSegment3D_(),
		new Detach_Collisions_Geometry3D_ClosestPointOnRay_Vector3_Ray_(),
		new Detach_Collisions_Geometry3D_ClosestPointOnTriangle_Vector3_Triangle3D_(),
		new Detach_Collisions_Geometry3D_ClosestPointInPyramid_Vector3_Pyramid_(),
		new Detach_Collisions_Geometry3D_ClosestPointInOrientedPyramid_Vector3_OrientedPyramid_(),
		new Detach_Collisions_Geometry3D_Raycast_Sphere_Ray_Single_(),
		new Detach_Collisions_Geometry3D_Raycast_Sphere_Ray_RaycastResult_(),
		new Detach_Collisions_Geometry3D_Raycast_Aabb_Ray_Single_(),
		new Detach_Collisions_Geometry3D_Raycast_Aabb_Ray_RaycastResult_(),
		new Detach_Collisions_Geometry3D_Raycast_Obb_Ray_Single_(),
		new Detach_Collisions_Geometry3D_Raycast_Obb_Ray_RaycastResult_(),
		new Detach_Collisions_Geometry3D_Raycast_Plane_Ray_Single_(),
		new Detach_Collisions_Geometry3D_Raycast_Plane_Ray_RaycastResult_(),
		new Detach_Collisions_Geometry3D_Raycast_Triangle3D_Ray_Single_(),
		new Detach_Collisions_Geometry3D_Raycast_Triangle3D_Ray_RaycastResult_(),
		new Detach_Collisions_Geometry3D_Raycast_Cylinder_Ray_Single_(),
		new Detach_Collisions_Geometry3D_SphereSphere_Sphere_Sphere_(),
		new Detach_Collisions_Geometry3D_SphereAabb_Sphere_Aabb_(),
		new Detach_Collisions_Geometry3D_SphereObb_Sphere_Obb_(),
		new Detach_Collisions_Geometry3D_SpherePlane_Sphere_Plane_(),
		new Detach_Collisions_Geometry3D_SphereViewFrustum_Sphere_ViewFrustum_(),
		new Detach_Collisions_Geometry3D_SphereCylinder_Sphere_Cylinder_(),
		new Detach_Collisions_Geometry3D_SphereConeFrustum_Sphere_ConeFrustum_(),
		new Detach_Collisions_Geometry3D_SpherePyramid_Sphere_Pyramid_(),
		new Detach_Collisions_Geometry3D_SphereOrientedPyramid_Sphere_OrientedPyramid_(),
		new Detach_Collisions_Geometry3D_SphereCastPoint_SphereCast_Vector3_(),
		new Detach_Collisions_Geometry3D_SphereCastLine_SphereCast_LineSegment3D_(),
		new Detach_Collisions_Geometry3D_SphereCastSphere_SphereCast_Sphere_(),
		new Detach_Collisions_Geometry3D_SphereCastSphereCast_SphereCast_SphereCast_(),
		new Detach_Collisions_Geometry3D_SphereCastAabb_SphereCast_Aabb_(),
		new Detach_Collisions_Geometry3D_SphereCastObb_SphereCast_Obb_(),
		new Detach_Collisions_Geometry3D_SphereCastTriangle_SphereCast_Triangle3D_(),
		new Detach_Collisions_Geometry3D_SphereCastTriangle_SphereCast_Triangle3D_Vector3_(),
		new Detach_Collisions_Geometry3D_SphereCastCylinder_SphereCast_Cylinder_(),
		new Detach_Collisions_Geometry3D_SphereCastConeFrustum_SphereCast_ConeFrustum_(),
		new Detach_Collisions_Geometry3D_SphereCastPyramid_SphereCast_Pyramid_(),
		new Detach_Collisions_Geometry3D_SphereCastOrientedPyramid_SphereCast_OrientedPyramid_(),
		new Detach_Collisions_Geometry3D_TriangleSphere_Triangle3D_Sphere_(),
		new Detach_Collisions_Geometry3D_TriangleAabb_Triangle3D_Aabb_(),
		new Detach_Collisions_Geometry3D_TriangleObb_Triangle3D_Obb_(),
		new Detach_Collisions_Geometry3D_TrianglePlane_Triangle3D_Plane_(),
		new Detach_Collisions_Geometry3D_TriangleTriangle_Triangle3D_Triangle3D_(),
		new Detach_Collisions_Geometry3D_TriangleTriangleRobust_Triangle3D_Triangle3D_(),
		new Detach_Collisions_Geometry3D_PlaneEquation_Vector3_Plane_(),
		new Detach_Collisions_Geometry3D_SatCrossEdge_Vector3_Vector3_Vector3_Vector3_(),
		new Detach_Collisions_Geometry3D_Barycentric_Vector3_Triangle3D_(),
		new Detach_Collisions_Geometry3D_Project_Vector2_Vector2_(),
		new Detach_Collisions_Geometry3D_Project_Vector3_Vector3_(),
		new Detach_Collisions_Geometry3D_Perpendicular_Vector2_Vector2_(),
		new Detach_Collisions_Geometry3D_Perpendicular_Vector3_Vector3_(),
		new Detach_Collisions_Geometry3D_FindCollisionFeatures_Sphere_Sphere_CollisionManifold_(),
		new Detach_Collisions_Geometry3D_FindCollisionFeatures_Obb_Sphere_CollisionManifold_(),
		new Detach_Collisions_Geometry3D_FindCollisionFeatures_Obb_Obb_CollisionManifold_(),
	];

	public static IReadOnlyList<IExecutableCollisionAlgorithm> All => _all;

	private sealed class Detach_Collisions_Geometry2D_CircleCircle_Circle_Circle_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry2D.CircleCircle(Circle,Circle)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Circle), "circle1"),
			(typeof(Circle), "circle2"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Circle argument0 = (Circle)nonOutArguments[0];
			Circle argument1 = (Circle)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry2D.CircleCircle(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry2D_CircleRectangle_Circle_Rectangle_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry2D.CircleRectangle(Circle,Rectangle)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Circle), "circle"),
			(typeof(Rectangle), "rectangle"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Circle argument0 = (Circle)nonOutArguments[0];
			Rectangle argument1 = (Rectangle)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry2D.CircleRectangle(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry2D_CircleOrientedRectangle_Circle_OrientedRectangle_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry2D.CircleOrientedRectangle(Circle,OrientedRectangle)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Circle), "circle"),
			(typeof(OrientedRectangle), "orientedRectangle"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Circle argument0 = (Circle)nonOutArguments[0];
			OrientedRectangle argument1 = (OrientedRectangle)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry2D.CircleOrientedRectangle(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry2D_CircleTriangle_Circle_Triangle2D_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry2D.CircleTriangle(Circle,Triangle2D)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Circle), "circle"),
			(typeof(Triangle2D), "triangle"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Circle argument0 = (Circle)nonOutArguments[0];
			Triangle2D argument1 = (Triangle2D)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry2D.CircleTriangle(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry2D_CircleCastPoint_CircleCast_Vector2_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry2D.CircleCastPoint(CircleCast,Vector2)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(CircleCast), "circleCast"),
			(typeof(Vector2), "point"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			CircleCast argument0 = (CircleCast)nonOutArguments[0];
			Vector2 argument1 = (Vector2)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry2D.CircleCastPoint(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry2D_CircleCastLine_CircleCast_LineSegment2D_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry2D.CircleCastLine(CircleCast,LineSegment2D)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(CircleCast), "circleCast"),
			(typeof(LineSegment2D), "line"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			CircleCast argument0 = (CircleCast)nonOutArguments[0];
			LineSegment2D argument1 = (LineSegment2D)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry2D.CircleCastLine(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry2D_LineLine_LineSegment2D_LineSegment2D_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry2D.LineLine(LineSegment2D,LineSegment2D)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(LineSegment2D), "line1"),
			(typeof(LineSegment2D), "line2"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			LineSegment2D argument0 = (LineSegment2D)nonOutArguments[0];
			LineSegment2D argument1 = (LineSegment2D)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry2D.LineLine(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry2D_LineCircle_LineSegment2D_Circle_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry2D.LineCircle(LineSegment2D,Circle)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(LineSegment2D), "line"),
			(typeof(Circle), "circle"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			LineSegment2D argument0 = (LineSegment2D)nonOutArguments[0];
			Circle argument1 = (Circle)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry2D.LineCircle(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry2D_LineRectangle_LineSegment2D_Rectangle_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry2D.LineRectangle(LineSegment2D,Rectangle)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(LineSegment2D), "line"),
			(typeof(Rectangle), "rectangle"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			LineSegment2D argument0 = (LineSegment2D)nonOutArguments[0];
			Rectangle argument1 = (Rectangle)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry2D.LineRectangle(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry2D_LineOrientedRectangle_LineSegment2D_OrientedRectangle_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry2D.LineOrientedRectangle(LineSegment2D,OrientedRectangle)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(LineSegment2D), "line"),
			(typeof(OrientedRectangle), "orientedRectangle"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			LineSegment2D argument0 = (LineSegment2D)nonOutArguments[0];
			OrientedRectangle argument1 = (OrientedRectangle)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry2D.LineOrientedRectangle(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry2D_LineTriangle_LineSegment2D_Triangle2D_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry2D.LineTriangle(LineSegment2D,Triangle2D)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(LineSegment2D), "line"),
			(typeof(Triangle2D), "triangle"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			LineSegment2D argument0 = (LineSegment2D)nonOutArguments[0];
			Triangle2D argument1 = (Triangle2D)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry2D.LineTriangle(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry2D_OrientedRectangleOrientedRectangleSat_OrientedRectangle_OrientedRectangle_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry2D.OrientedRectangleOrientedRectangleSat(OrientedRectangle,OrientedRectangle)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(OrientedRectangle), "orientedRectangle1"),
			(typeof(OrientedRectangle), "orientedRectangle2"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			OrientedRectangle argument0 = (OrientedRectangle)nonOutArguments[0];
			OrientedRectangle argument1 = (OrientedRectangle)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry2D.OrientedRectangleOrientedRectangleSat(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry2D_OrientedRectangleTriangle_OrientedRectangle_Triangle2D_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry2D.OrientedRectangleTriangle(OrientedRectangle,Triangle2D)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(OrientedRectangle), "orientedRectangle"),
			(typeof(Triangle2D), "triangle"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			OrientedRectangle argument0 = (OrientedRectangle)nonOutArguments[0];
			Triangle2D argument1 = (Triangle2D)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry2D.OrientedRectangleTriangle(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry2D_PointOnLine_Vector2_LineSegment2D_Single_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry2D.PointOnLine(Vector2,LineSegment2D,Single)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector2), "point"),
			(typeof(LineSegment2D), "line"),
			(typeof(Single), "epsilon"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 3.");

			Vector2 argument0 = (Vector2)nonOutArguments[0];
			LineSegment2D argument1 = (LineSegment2D)nonOutArguments[1];
			Single argument2 = (Single)nonOutArguments[2];

			System.Boolean returnValue = Detach.Collisions.Geometry2D.PointOnLine(argument0, argument1, argument2);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry2D_PointInCircle_Vector2_Circle_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry2D.PointInCircle(Vector2,Circle)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector2), "point"),
			(typeof(Circle), "circle"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector2 argument0 = (Vector2)nonOutArguments[0];
			Circle argument1 = (Circle)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry2D.PointInCircle(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry2D_PointInRectangle_Vector2_Rectangle_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry2D.PointInRectangle(Vector2,Rectangle)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector2), "point"),
			(typeof(Rectangle), "rectangle"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector2 argument0 = (Vector2)nonOutArguments[0];
			Rectangle argument1 = (Rectangle)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry2D.PointInRectangle(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry2D_PointInOrientedRectangle_Vector2_OrientedRectangle_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry2D.PointInOrientedRectangle(Vector2,OrientedRectangle)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector2), "point"),
			(typeof(OrientedRectangle), "orientedRectangle"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector2 argument0 = (Vector2)nonOutArguments[0];
			OrientedRectangle argument1 = (OrientedRectangle)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry2D.PointInOrientedRectangle(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry2D_PointInTriangle_Vector2_Triangle2D_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry2D.PointInTriangle(Vector2,Triangle2D)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector2), "point"),
			(typeof(Triangle2D), "triangle"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector2 argument0 = (Vector2)nonOutArguments[0];
			Triangle2D argument1 = (Triangle2D)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry2D.PointInTriangle(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry2D_ClosestPointOnLine_Vector2_LineSegment2D_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry2D.ClosestPointOnLine(Vector2,LineSegment2D)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector2), "point"),
			(typeof(LineSegment2D), "line"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Numerics.Vector2);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector2 argument0 = (Vector2)nonOutArguments[0];
			LineSegment2D argument1 = (LineSegment2D)nonOutArguments[1];

			System.Numerics.Vector2 returnValue = Detach.Collisions.Geometry2D.ClosestPointOnLine(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry2D_RectangleRectangle_Rectangle_Rectangle_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry2D.RectangleRectangle(Rectangle,Rectangle)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Rectangle), "rectangle1"),
			(typeof(Rectangle), "rectangle2"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Rectangle argument0 = (Rectangle)nonOutArguments[0];
			Rectangle argument1 = (Rectangle)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry2D.RectangleRectangle(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry2D_RectangleRectangleSat_Rectangle_Rectangle_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry2D.RectangleRectangleSat(Rectangle,Rectangle)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Rectangle), "rectangle1"),
			(typeof(Rectangle), "rectangle2"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Rectangle argument0 = (Rectangle)nonOutArguments[0];
			Rectangle argument1 = (Rectangle)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry2D.RectangleRectangleSat(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry2D_RectangleOrientedRectangleSat_Rectangle_OrientedRectangle_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry2D.RectangleOrientedRectangleSat(Rectangle,OrientedRectangle)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Rectangle), "rectangle"),
			(typeof(OrientedRectangle), "orientedRectangle"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Rectangle argument0 = (Rectangle)nonOutArguments[0];
			OrientedRectangle argument1 = (OrientedRectangle)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry2D.RectangleOrientedRectangleSat(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry2D_RectangleTriangle_Rectangle_Triangle2D_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry2D.RectangleTriangle(Rectangle,Triangle2D)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Rectangle), "rectangle"),
			(typeof(Triangle2D), "triangle"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Rectangle argument0 = (Rectangle)nonOutArguments[0];
			Triangle2D argument1 = (Triangle2D)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry2D.RectangleTriangle(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_AabbAabb_Aabb_Aabb_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.AabbAabb(Aabb,Aabb)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Aabb), "aabb1"),
			(typeof(Aabb), "aabb2"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Aabb argument0 = (Aabb)nonOutArguments[0];
			Aabb argument1 = (Aabb)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.AabbAabb(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_AabbObbSat_Aabb_Obb_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.AabbObbSat(Aabb,Obb)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Aabb), "aabb"),
			(typeof(Obb), "obb"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Aabb argument0 = (Aabb)nonOutArguments[0];
			Obb argument1 = (Obb)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.AabbObbSat(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_AabbPlane_Aabb_Plane_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.AabbPlane(Aabb,Plane)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Aabb), "aabb"),
			(typeof(Plane), "plane"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Aabb argument0 = (Aabb)nonOutArguments[0];
			Plane argument1 = (Plane)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.AabbPlane(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_AabbCylinder_Aabb_Cylinder_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.AabbCylinder(Aabb,Cylinder)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Aabb), "aabb"),
			(typeof(Cylinder), "cylinder"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Aabb argument0 = (Aabb)nonOutArguments[0];
			Cylinder argument1 = (Cylinder)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.AabbCylinder(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_CylinderCylinder_Cylinder_Cylinder_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.CylinderCylinder(Cylinder,Cylinder)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Cylinder), "cylinder1"),
			(typeof(Cylinder), "cylinder2"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Cylinder argument0 = (Cylinder)nonOutArguments[0];
			Cylinder argument1 = (Cylinder)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.CylinderCylinder(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_Linetest_Sphere_LineSegment3D_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.Linetest(Sphere,LineSegment3D)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Sphere), "sphere"),
			(typeof(LineSegment3D), "line"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Sphere argument0 = (Sphere)nonOutArguments[0];
			LineSegment3D argument1 = (LineSegment3D)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.Linetest(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_Linetest_Aabb_LineSegment3D_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.Linetest(Aabb,LineSegment3D)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Aabb), "aabb"),
			(typeof(LineSegment3D), "line"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Aabb argument0 = (Aabb)nonOutArguments[0];
			LineSegment3D argument1 = (LineSegment3D)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.Linetest(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_Linetest_Obb_LineSegment3D_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.Linetest(Obb,LineSegment3D)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Obb), "obb"),
			(typeof(LineSegment3D), "line"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Obb argument0 = (Obb)nonOutArguments[0];
			LineSegment3D argument1 = (LineSegment3D)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.Linetest(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_Linetest_Plane_LineSegment3D_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.Linetest(Plane,LineSegment3D)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Plane), "plane"),
			(typeof(LineSegment3D), "line"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Plane argument0 = (Plane)nonOutArguments[0];
			LineSegment3D argument1 = (LineSegment3D)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.Linetest(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_Linetest_Triangle3D_LineSegment3D_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.Linetest(Triangle3D,LineSegment3D)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Triangle3D), "triangle"),
			(typeof(LineSegment3D), "line"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Triangle3D argument0 = (Triangle3D)nonOutArguments[0];
			LineSegment3D argument1 = (LineSegment3D)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.Linetest(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_ObbObbSat_Obb_Obb_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.ObbObbSat(Obb,Obb)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Obb), "obb1"),
			(typeof(Obb), "obb2"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Obb argument0 = (Obb)nonOutArguments[0];
			Obb argument1 = (Obb)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.ObbObbSat(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_ObbPlane_Obb_Plane_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.ObbPlane(Obb,Plane)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Obb), "obb"),
			(typeof(Plane), "plane"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Obb argument0 = (Obb)nonOutArguments[0];
			Plane argument1 = (Plane)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.ObbPlane(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_PlanePlane_Plane_Plane_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.PlanePlane(Plane,Plane)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Plane), "plane1"),
			(typeof(Plane), "plane2"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Plane argument0 = (Plane)nonOutArguments[0];
			Plane argument1 = (Plane)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.PlanePlane(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_PointInSphere_Vector3_Sphere_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.PointInSphere(Vector3,Sphere)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "point"),
			(typeof(Sphere), "sphere"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector3 argument0 = (Vector3)nonOutArguments[0];
			Sphere argument1 = (Sphere)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.PointInSphere(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_PointInAabb_Vector3_Aabb_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.PointInAabb(Vector3,Aabb)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "point"),
			(typeof(Aabb), "aabb"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector3 argument0 = (Vector3)nonOutArguments[0];
			Aabb argument1 = (Aabb)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.PointInAabb(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_PointInObb_Vector3_Obb_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.PointInObb(Vector3,Obb)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "point"),
			(typeof(Obb), "obb"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector3 argument0 = (Vector3)nonOutArguments[0];
			Obb argument1 = (Obb)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.PointInObb(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_PointOnPlane_Vector3_Plane_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.PointOnPlane(Vector3,Plane)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "point"),
			(typeof(Plane), "plane"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector3 argument0 = (Vector3)nonOutArguments[0];
			Plane argument1 = (Plane)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.PointOnPlane(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_PointOnLine_Vector3_LineSegment3D_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.PointOnLine(Vector3,LineSegment3D)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "point"),
			(typeof(LineSegment3D), "line"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector3 argument0 = (Vector3)nonOutArguments[0];
			LineSegment3D argument1 = (LineSegment3D)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.PointOnLine(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_PointOnRay_Vector3_Ray_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.PointOnRay(Vector3,Ray)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "point"),
			(typeof(Ray), "ray"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector3 argument0 = (Vector3)nonOutArguments[0];
			Ray argument1 = (Ray)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.PointOnRay(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_PointInTriangle_Vector3_Triangle3D_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.PointInTriangle(Vector3,Triangle3D)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "point"),
			(typeof(Triangle3D), "triangle"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector3 argument0 = (Vector3)nonOutArguments[0];
			Triangle3D argument1 = (Triangle3D)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.PointInTriangle(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_PointInViewFrustum_Vector3_ViewFrustum_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.PointInViewFrustum(Vector3,ViewFrustum)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "point"),
			(typeof(ViewFrustum), "viewFrustum"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector3 argument0 = (Vector3)nonOutArguments[0];
			ViewFrustum argument1 = (ViewFrustum)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.PointInViewFrustum(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_PointInCylinder_Vector3_Cylinder_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.PointInCylinder(Vector3,Cylinder)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "point"),
			(typeof(Cylinder), "cylinder"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector3 argument0 = (Vector3)nonOutArguments[0];
			Cylinder argument1 = (Cylinder)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.PointInCylinder(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_PointInPyramid_Vector3_Pyramid_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.PointInPyramid(Vector3,Pyramid)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "point"),
			(typeof(Pyramid), "pyramid"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector3 argument0 = (Vector3)nonOutArguments[0];
			Pyramid argument1 = (Pyramid)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.PointInPyramid(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_PointInOrientedPyramid_Vector3_OrientedPyramid_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.PointInOrientedPyramid(Vector3,OrientedPyramid)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "point"),
			(typeof(OrientedPyramid), "orientedPyramid"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector3 argument0 = (Vector3)nonOutArguments[0];
			OrientedPyramid argument1 = (OrientedPyramid)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.PointInOrientedPyramid(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_ClosestPointInSphere_Vector3_Sphere_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.ClosestPointInSphere(Vector3,Sphere)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "point"),
			(typeof(Sphere), "sphere"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Numerics.Vector3);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector3 argument0 = (Vector3)nonOutArguments[0];
			Sphere argument1 = (Sphere)nonOutArguments[1];

			System.Numerics.Vector3 returnValue = Detach.Collisions.Geometry3D.ClosestPointInSphere(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_ClosestPointInAabb_Vector3_Aabb_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.ClosestPointInAabb(Vector3,Aabb)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "point"),
			(typeof(Aabb), "aabb"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Numerics.Vector3);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector3 argument0 = (Vector3)nonOutArguments[0];
			Aabb argument1 = (Aabb)nonOutArguments[1];

			System.Numerics.Vector3 returnValue = Detach.Collisions.Geometry3D.ClosestPointInAabb(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_ClosestPointInObb_Vector3_Obb_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.ClosestPointInObb(Vector3,Obb)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "point"),
			(typeof(Obb), "obb"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Numerics.Vector3);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector3 argument0 = (Vector3)nonOutArguments[0];
			Obb argument1 = (Obb)nonOutArguments[1];

			System.Numerics.Vector3 returnValue = Detach.Collisions.Geometry3D.ClosestPointInObb(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_ClosestPointOnPlane_Vector3_Plane_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.ClosestPointOnPlane(Vector3,Plane)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "point"),
			(typeof(Plane), "plane"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Numerics.Vector3);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector3 argument0 = (Vector3)nonOutArguments[0];
			Plane argument1 = (Plane)nonOutArguments[1];

			System.Numerics.Vector3 returnValue = Detach.Collisions.Geometry3D.ClosestPointOnPlane(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_ClosestPointOnLine_Vector3_LineSegment3D_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.ClosestPointOnLine(Vector3,LineSegment3D)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "point"),
			(typeof(LineSegment3D), "line"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Numerics.Vector3);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector3 argument0 = (Vector3)nonOutArguments[0];
			LineSegment3D argument1 = (LineSegment3D)nonOutArguments[1];

			System.Numerics.Vector3 returnValue = Detach.Collisions.Geometry3D.ClosestPointOnLine(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_ClosestPointOnRay_Vector3_Ray_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.ClosestPointOnRay(Vector3,Ray)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "point"),
			(typeof(Ray), "ray"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Numerics.Vector3);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector3 argument0 = (Vector3)nonOutArguments[0];
			Ray argument1 = (Ray)nonOutArguments[1];

			System.Numerics.Vector3 returnValue = Detach.Collisions.Geometry3D.ClosestPointOnRay(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_ClosestPointOnTriangle_Vector3_Triangle3D_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.ClosestPointOnTriangle(Vector3,Triangle3D)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "point"),
			(typeof(Triangle3D), "triangle"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Numerics.Vector3);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector3 argument0 = (Vector3)nonOutArguments[0];
			Triangle3D argument1 = (Triangle3D)nonOutArguments[1];

			System.Numerics.Vector3 returnValue = Detach.Collisions.Geometry3D.ClosestPointOnTriangle(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_ClosestPointInPyramid_Vector3_Pyramid_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.ClosestPointInPyramid(Vector3,Pyramid)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "point"),
			(typeof(Pyramid), "pyramid"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Numerics.Vector3);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector3 argument0 = (Vector3)nonOutArguments[0];
			Pyramid argument1 = (Pyramid)nonOutArguments[1];

			System.Numerics.Vector3 returnValue = Detach.Collisions.Geometry3D.ClosestPointInPyramid(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_ClosestPointInOrientedPyramid_Vector3_OrientedPyramid_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.ClosestPointInOrientedPyramid(Vector3,OrientedPyramid)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "point"),
			(typeof(OrientedPyramid), "pyramid"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Numerics.Vector3);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector3 argument0 = (Vector3)nonOutArguments[0];
			OrientedPyramid argument1 = (OrientedPyramid)nonOutArguments[1];

			System.Numerics.Vector3 returnValue = Detach.Collisions.Geometry3D.ClosestPointInOrientedPyramid(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_Raycast_Sphere_Ray_Single_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.Raycast(Sphere,Ray,Single)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Sphere), "sphere"),
			(typeof(Ray), "ray"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Single), "distance"),
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Sphere argument0 = (Sphere)nonOutArguments[0];
			Ray argument1 = (Ray)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.Raycast(argument0, argument1, out Single outArgument0);
			return new ExecutionResult(returnValue, [outArgument0]);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_Raycast_Sphere_Ray_RaycastResult_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.Raycast(Sphere,Ray,RaycastResult)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Sphere), "sphere"),
			(typeof(Ray), "ray"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(RaycastResult), "result"),
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Sphere argument0 = (Sphere)nonOutArguments[0];
			Ray argument1 = (Ray)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.Raycast(argument0, argument1, out RaycastResult outArgument0);
			return new ExecutionResult(returnValue, [outArgument0]);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_Raycast_Aabb_Ray_Single_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.Raycast(Aabb,Ray,Single)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Aabb), "aabb"),
			(typeof(Ray), "ray"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Single), "distance"),
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Aabb argument0 = (Aabb)nonOutArguments[0];
			Ray argument1 = (Ray)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.Raycast(argument0, argument1, out Single outArgument0);
			return new ExecutionResult(returnValue, [outArgument0]);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_Raycast_Aabb_Ray_RaycastResult_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.Raycast(Aabb,Ray,RaycastResult)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Aabb), "aabb"),
			(typeof(Ray), "ray"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(RaycastResult), "result"),
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Aabb argument0 = (Aabb)nonOutArguments[0];
			Ray argument1 = (Ray)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.Raycast(argument0, argument1, out RaycastResult outArgument0);
			return new ExecutionResult(returnValue, [outArgument0]);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_Raycast_Obb_Ray_Single_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.Raycast(Obb,Ray,Single)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Obb), "obb"),
			(typeof(Ray), "ray"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Single), "distance"),
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Obb argument0 = (Obb)nonOutArguments[0];
			Ray argument1 = (Ray)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.Raycast(argument0, argument1, out Single outArgument0);
			return new ExecutionResult(returnValue, [outArgument0]);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_Raycast_Obb_Ray_RaycastResult_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.Raycast(Obb,Ray,RaycastResult)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Obb), "obb"),
			(typeof(Ray), "ray"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(RaycastResult), "result"),
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Obb argument0 = (Obb)nonOutArguments[0];
			Ray argument1 = (Ray)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.Raycast(argument0, argument1, out RaycastResult outArgument0);
			return new ExecutionResult(returnValue, [outArgument0]);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_Raycast_Plane_Ray_Single_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.Raycast(Plane,Ray,Single)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Plane), "plane"),
			(typeof(Ray), "ray"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Single), "distance"),
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Plane argument0 = (Plane)nonOutArguments[0];
			Ray argument1 = (Ray)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.Raycast(argument0, argument1, out Single outArgument0);
			return new ExecutionResult(returnValue, [outArgument0]);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_Raycast_Plane_Ray_RaycastResult_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.Raycast(Plane,Ray,RaycastResult)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Plane), "plane"),
			(typeof(Ray), "ray"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(RaycastResult), "result"),
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Plane argument0 = (Plane)nonOutArguments[0];
			Ray argument1 = (Ray)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.Raycast(argument0, argument1, out RaycastResult outArgument0);
			return new ExecutionResult(returnValue, [outArgument0]);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_Raycast_Triangle3D_Ray_Single_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.Raycast(Triangle3D,Ray,Single)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Triangle3D), "triangle"),
			(typeof(Ray), "ray"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Single), "distance"),
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Triangle3D argument0 = (Triangle3D)nonOutArguments[0];
			Ray argument1 = (Ray)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.Raycast(argument0, argument1, out Single outArgument0);
			return new ExecutionResult(returnValue, [outArgument0]);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_Raycast_Triangle3D_Ray_RaycastResult_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.Raycast(Triangle3D,Ray,RaycastResult)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Triangle3D), "triangle"),
			(typeof(Ray), "ray"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(RaycastResult), "raycastResult"),
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Triangle3D argument0 = (Triangle3D)nonOutArguments[0];
			Ray argument1 = (Ray)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.Raycast(argument0, argument1, out RaycastResult outArgument0);
			return new ExecutionResult(returnValue, [outArgument0]);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_Raycast_Cylinder_Ray_Single_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.Raycast(Cylinder,Ray,Single)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Cylinder), "cylinder"),
			(typeof(Ray), "ray"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Single), "distance"),
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Cylinder argument0 = (Cylinder)nonOutArguments[0];
			Ray argument1 = (Ray)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.Raycast(argument0, argument1, out Single outArgument0);
			return new ExecutionResult(returnValue, [outArgument0]);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_SphereSphere_Sphere_Sphere_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.SphereSphere(Sphere,Sphere)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Sphere), "sphere1"),
			(typeof(Sphere), "sphere2"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Sphere argument0 = (Sphere)nonOutArguments[0];
			Sphere argument1 = (Sphere)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.SphereSphere(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_SphereAabb_Sphere_Aabb_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.SphereAabb(Sphere,Aabb)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Sphere), "sphere"),
			(typeof(Aabb), "aabb"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Sphere argument0 = (Sphere)nonOutArguments[0];
			Aabb argument1 = (Aabb)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.SphereAabb(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_SphereObb_Sphere_Obb_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.SphereObb(Sphere,Obb)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Sphere), "sphere"),
			(typeof(Obb), "obb"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Sphere argument0 = (Sphere)nonOutArguments[0];
			Obb argument1 = (Obb)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.SphereObb(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_SpherePlane_Sphere_Plane_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.SpherePlane(Sphere,Plane)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Sphere), "sphere"),
			(typeof(Plane), "plane"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Sphere argument0 = (Sphere)nonOutArguments[0];
			Plane argument1 = (Plane)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.SpherePlane(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_SphereViewFrustum_Sphere_ViewFrustum_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.SphereViewFrustum(Sphere,ViewFrustum)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Sphere), "sphere"),
			(typeof(ViewFrustum), "viewFrustum"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Sphere argument0 = (Sphere)nonOutArguments[0];
			ViewFrustum argument1 = (ViewFrustum)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.SphereViewFrustum(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_SphereCylinder_Sphere_Cylinder_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.SphereCylinder(Sphere,Cylinder)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Sphere), "sphere"),
			(typeof(Cylinder), "cylinder"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Sphere argument0 = (Sphere)nonOutArguments[0];
			Cylinder argument1 = (Cylinder)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.SphereCylinder(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_SphereConeFrustum_Sphere_ConeFrustum_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.SphereConeFrustum(Sphere,ConeFrustum)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Sphere), "sphere"),
			(typeof(ConeFrustum), "coneFrustum"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Sphere argument0 = (Sphere)nonOutArguments[0];
			ConeFrustum argument1 = (ConeFrustum)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.SphereConeFrustum(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_SpherePyramid_Sphere_Pyramid_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.SpherePyramid(Sphere,Pyramid)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Sphere), "sphere"),
			(typeof(Pyramid), "pyramid"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Sphere argument0 = (Sphere)nonOutArguments[0];
			Pyramid argument1 = (Pyramid)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.SpherePyramid(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_SphereOrientedPyramid_Sphere_OrientedPyramid_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.SphereOrientedPyramid(Sphere,OrientedPyramid)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Sphere), "sphere"),
			(typeof(OrientedPyramid), "orientedPyramid"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Sphere argument0 = (Sphere)nonOutArguments[0];
			OrientedPyramid argument1 = (OrientedPyramid)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.SphereOrientedPyramid(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_SphereCastPoint_SphereCast_Vector3_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.SphereCastPoint(SphereCast,Vector3)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(SphereCast), "sphereCast"),
			(typeof(Vector3), "point"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			SphereCast argument0 = (SphereCast)nonOutArguments[0];
			Vector3 argument1 = (Vector3)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.SphereCastPoint(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_SphereCastLine_SphereCast_LineSegment3D_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.SphereCastLine(SphereCast,LineSegment3D)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(SphereCast), "sphereCast"),
			(typeof(LineSegment3D), "line"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			SphereCast argument0 = (SphereCast)nonOutArguments[0];
			LineSegment3D argument1 = (LineSegment3D)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.SphereCastLine(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_SphereCastSphere_SphereCast_Sphere_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.SphereCastSphere(SphereCast,Sphere)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(SphereCast), "sphereCast"),
			(typeof(Sphere), "sphere"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			SphereCast argument0 = (SphereCast)nonOutArguments[0];
			Sphere argument1 = (Sphere)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.SphereCastSphere(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_SphereCastSphereCast_SphereCast_SphereCast_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.SphereCastSphereCast(SphereCast,SphereCast)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(SphereCast), "sphereCast1"),
			(typeof(SphereCast), "sphereCast2"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			SphereCast argument0 = (SphereCast)nonOutArguments[0];
			SphereCast argument1 = (SphereCast)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.SphereCastSphereCast(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_SphereCastAabb_SphereCast_Aabb_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.SphereCastAabb(SphereCast,Aabb)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(SphereCast), "sphereCast"),
			(typeof(Aabb), "aabb"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			SphereCast argument0 = (SphereCast)nonOutArguments[0];
			Aabb argument1 = (Aabb)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.SphereCastAabb(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_SphereCastObb_SphereCast_Obb_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.SphereCastObb(SphereCast,Obb)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(SphereCast), "sphereCast"),
			(typeof(Obb), "obb"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			SphereCast argument0 = (SphereCast)nonOutArguments[0];
			Obb argument1 = (Obb)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.SphereCastObb(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_SphereCastTriangle_SphereCast_Triangle3D_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.SphereCastTriangle(SphereCast,Triangle3D)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(SphereCast), "sphereCast"),
			(typeof(Triangle3D), "triangle"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			SphereCast argument0 = (SphereCast)nonOutArguments[0];
			Triangle3D argument1 = (Triangle3D)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.SphereCastTriangle(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_SphereCastTriangle_SphereCast_Triangle3D_Vector3_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.SphereCastTriangle(SphereCast,Triangle3D,Vector3)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(SphereCast), "sphereCast"),
			(typeof(Triangle3D), "triangle"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "intersectionPoint"),
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			SphereCast argument0 = (SphereCast)nonOutArguments[0];
			Triangle3D argument1 = (Triangle3D)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.SphereCastTriangle(argument0, argument1, out Vector3 outArgument0);
			return new ExecutionResult(returnValue, [outArgument0]);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_SphereCastCylinder_SphereCast_Cylinder_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.SphereCastCylinder(SphereCast,Cylinder)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(SphereCast), "sphereCast"),
			(typeof(Cylinder), "cylinder"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			SphereCast argument0 = (SphereCast)nonOutArguments[0];
			Cylinder argument1 = (Cylinder)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.SphereCastCylinder(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_SphereCastConeFrustum_SphereCast_ConeFrustum_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.SphereCastConeFrustum(SphereCast,ConeFrustum)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(SphereCast), "sphereCast"),
			(typeof(ConeFrustum), "coneFrustum"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			SphereCast argument0 = (SphereCast)nonOutArguments[0];
			ConeFrustum argument1 = (ConeFrustum)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.SphereCastConeFrustum(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_SphereCastPyramid_SphereCast_Pyramid_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.SphereCastPyramid(SphereCast,Pyramid)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(SphereCast), "sphereCast"),
			(typeof(Pyramid), "pyramid"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			SphereCast argument0 = (SphereCast)nonOutArguments[0];
			Pyramid argument1 = (Pyramid)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.SphereCastPyramid(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_SphereCastOrientedPyramid_SphereCast_OrientedPyramid_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.SphereCastOrientedPyramid(SphereCast,OrientedPyramid)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(SphereCast), "sphereCast"),
			(typeof(OrientedPyramid), "orientedPyramid"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			SphereCast argument0 = (SphereCast)nonOutArguments[0];
			OrientedPyramid argument1 = (OrientedPyramid)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.SphereCastOrientedPyramid(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_TriangleSphere_Triangle3D_Sphere_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.TriangleSphere(Triangle3D,Sphere)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Triangle3D), "triangle"),
			(typeof(Sphere), "sphere"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Triangle3D argument0 = (Triangle3D)nonOutArguments[0];
			Sphere argument1 = (Sphere)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.TriangleSphere(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_TriangleAabb_Triangle3D_Aabb_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.TriangleAabb(Triangle3D,Aabb)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Triangle3D), "triangle"),
			(typeof(Aabb), "aabb"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Triangle3D argument0 = (Triangle3D)nonOutArguments[0];
			Aabb argument1 = (Aabb)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.TriangleAabb(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_TriangleObb_Triangle3D_Obb_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.TriangleObb(Triangle3D,Obb)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Triangle3D), "triangle"),
			(typeof(Obb), "obb"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Triangle3D argument0 = (Triangle3D)nonOutArguments[0];
			Obb argument1 = (Obb)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.TriangleObb(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_TrianglePlane_Triangle3D_Plane_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.TrianglePlane(Triangle3D,Plane)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Triangle3D), "triangle"),
			(typeof(Plane), "plane"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Triangle3D argument0 = (Triangle3D)nonOutArguments[0];
			Plane argument1 = (Plane)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.TrianglePlane(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_TriangleTriangle_Triangle3D_Triangle3D_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.TriangleTriangle(Triangle3D,Triangle3D)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Triangle3D), "triangle1"),
			(typeof(Triangle3D), "triangle2"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Triangle3D argument0 = (Triangle3D)nonOutArguments[0];
			Triangle3D argument1 = (Triangle3D)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.TriangleTriangle(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_TriangleTriangleRobust_Triangle3D_Triangle3D_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.TriangleTriangleRobust(Triangle3D,Triangle3D)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Triangle3D), "triangle1"),
			(typeof(Triangle3D), "triangle2"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Triangle3D argument0 = (Triangle3D)nonOutArguments[0];
			Triangle3D argument1 = (Triangle3D)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.TriangleTriangleRobust(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_PlaneEquation_Vector3_Plane_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.PlaneEquation(Vector3,Plane)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "point"),
			(typeof(Plane), "plane"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Single);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector3 argument0 = (Vector3)nonOutArguments[0];
			Plane argument1 = (Plane)nonOutArguments[1];

			System.Single returnValue = Detach.Collisions.Geometry3D.PlaneEquation(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_SatCrossEdge_Vector3_Vector3_Vector3_Vector3_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.SatCrossEdge(Vector3,Vector3,Vector3,Vector3)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "a"),
			(typeof(Vector3), "b"),
			(typeof(Vector3), "c"),
			(typeof(Vector3), "d"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Numerics.Vector3);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 4.");

			Vector3 argument0 = (Vector3)nonOutArguments[0];
			Vector3 argument1 = (Vector3)nonOutArguments[1];
			Vector3 argument2 = (Vector3)nonOutArguments[2];
			Vector3 argument3 = (Vector3)nonOutArguments[3];

			System.Numerics.Vector3 returnValue = Detach.Collisions.Geometry3D.SatCrossEdge(argument0, argument1, argument2, argument3);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_Barycentric_Vector3_Triangle3D_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.Barycentric(Vector3,Triangle3D)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "point"),
			(typeof(Triangle3D), "triangle"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Numerics.Vector3);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector3 argument0 = (Vector3)nonOutArguments[0];
			Triangle3D argument1 = (Triangle3D)nonOutArguments[1];

			System.Numerics.Vector3 returnValue = Detach.Collisions.Geometry3D.Barycentric(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_Project_Vector2_Vector2_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.Project(Vector2,Vector2)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector2), "length"),
			(typeof(Vector2), "direction"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Numerics.Vector2);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector2 argument0 = (Vector2)nonOutArguments[0];
			Vector2 argument1 = (Vector2)nonOutArguments[1];

			System.Numerics.Vector2 returnValue = Detach.Collisions.Geometry3D.Project(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_Project_Vector3_Vector3_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.Project(Vector3,Vector3)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "length"),
			(typeof(Vector3), "direction"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Numerics.Vector3);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector3 argument0 = (Vector3)nonOutArguments[0];
			Vector3 argument1 = (Vector3)nonOutArguments[1];

			System.Numerics.Vector3 returnValue = Detach.Collisions.Geometry3D.Project(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_Perpendicular_Vector2_Vector2_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.Perpendicular(Vector2,Vector2)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector2), "length"),
			(typeof(Vector2), "direction"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Numerics.Vector2);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector2 argument0 = (Vector2)nonOutArguments[0];
			Vector2 argument1 = (Vector2)nonOutArguments[1];

			System.Numerics.Vector2 returnValue = Detach.Collisions.Geometry3D.Perpendicular(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_Perpendicular_Vector3_Vector3_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.Perpendicular(Vector3,Vector3)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Vector3), "length"),
			(typeof(Vector3), "direction"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
		};

		public Type ReturnType { get; } = typeof(System.Numerics.Vector3);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Vector3 argument0 = (Vector3)nonOutArguments[0];
			Vector3 argument1 = (Vector3)nonOutArguments[1];

			System.Numerics.Vector3 returnValue = Detach.Collisions.Geometry3D.Perpendicular(argument0, argument1);
			return new ExecutionResult(returnValue, []);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_FindCollisionFeatures_Sphere_Sphere_CollisionManifold_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.FindCollisionFeatures(Sphere,Sphere,CollisionManifold)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Sphere), "sphere1"),
			(typeof(Sphere), "sphere2"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(CollisionManifold), "collisionManifold"),
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Sphere argument0 = (Sphere)nonOutArguments[0];
			Sphere argument1 = (Sphere)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.FindCollisionFeatures(argument0, argument1, out CollisionManifold outArgument0);
			return new ExecutionResult(returnValue, [outArgument0]);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_FindCollisionFeatures_Obb_Sphere_CollisionManifold_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.FindCollisionFeatures(Obb,Sphere,CollisionManifold)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Obb), "obb"),
			(typeof(Sphere), "sphere"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(CollisionManifold), "collisionManifold"),
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Obb argument0 = (Obb)nonOutArguments[0];
			Sphere argument1 = (Sphere)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.FindCollisionFeatures(argument0, argument1, out CollisionManifold outArgument0);
			return new ExecutionResult(returnValue, [outArgument0]);
		}
	}

	private sealed class Detach_Collisions_Geometry3D_FindCollisionFeatures_Obb_Obb_CollisionManifold_ : IExecutableCollisionAlgorithm
	{
		public string Name => "Detach.Collisions.Geometry3D.FindCollisionFeatures(Obb,Obb,CollisionManifold)";

		public IReadOnlyList<(Type Type, string Name)> Parameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(Obb), "obb1"),
			(typeof(Obb), "obb2"),
		};

		public IReadOnlyList<(Type Type, string Name)> OutParameters { get; } = new List<(Type Type, string Name)>
		{
			(typeof(CollisionManifold), "collisionManifold"),
		};

		public Type ReturnType { get; } = typeof(System.Boolean);

		public ExecutionResult Execute(List<object> nonOutArguments)
		{
			if (nonOutArguments.Count != Parameters.Count)
				throw new ArgumentException("The number of arguments must be 2.");

			Obb argument0 = (Obb)nonOutArguments[0];
			Obb argument1 = (Obb)nonOutArguments[1];

			System.Boolean returnValue = Detach.Collisions.Geometry3D.FindCollisionFeatures(argument0, argument1, out CollisionManifold outArgument0);
			return new ExecutionResult(returnValue, [outArgument0]);
		}
	}

}
